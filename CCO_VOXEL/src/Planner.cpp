/**
 * Fast Planner with Octomap and EDT3D library
 **/
/**
 * Octomap generation using point cloud from depth camera and pose from PX4-EKF
 * Fixed Window (8,8,8) EDT calculation using EDT3D library
 * Planning in the window using kino-dynamic A* algorithm
 * Horizon limitation due to limitation of range sensor
 * Drone controlled using PX4-Offboard position control
 **/

#include "CCO_VOXEL/utils.h"
#include <chrono>
using std::chrono::duration_cast;
using std::chrono::high_resolution_clock;
using std::chrono::microseconds;
/** Planning and mapping headers **/
#include "CCO_VOXEL/kinodynamic_astar.h"
#include "CCO_VOXEL/Optimization.h"
#include "CCO_VOXEL/Map.h"

#include "CCO_VOXEL/edtDistribution.h"
#include "CCO_VOXEL/crossEntropyOptimizer.h"

#include "std_msgs/Float64.h"

#include <math.h>

/** Drone states for planner **/
Eigen::Vector3d goalPose, currPose, startPose, startVel, startAcc, goalVel, curr_pose_EDT;

/** Overall trajectory **/
std::vector<Eigen::Vector3d> trajectory;
nav_msgs::Path generatedPath;
nav_msgs::Path Optimized_path;
Optimizer::CrossEntropyOptimizer optimizer;
nav_msgs::Path fastPlannerOriginal;

std::string path_to_weights;

/** EDT distance for each waypoint in the path generated by fast planner **/
nav_msgs::Path generatedPathEDT;
Optimization::CEOptim optmize;
/** time step to generate the trajectory **/
float deltaT = 0.1;

// MMDFunctions::MMD_map MMD_Costmap;

/** Initialize the planner and mapping objects **/
fast_planner::KinodynamicAstar kAstar;
Map3D::OctoMapEDT costMap3D;

// MMD_Map::MMD_Map_Functions  MMD_costmap;

/** decision variables **/
bool goalReceived = false;
bool DESTINATION_REACHED = false;
bool PLAN = false;
int startOver = 0;

int count; // count for planning iteration

#define INF 1000 // inifinity

// trajectory regeneration
std::vector<Eigen::Vector3d> prevTraj;

/** Cost Map visualization **/
visualization_msgs::MarkerArray costMap_vis;

visualization_msgs::MarkerArray MMD_map_vis;
visualization_msgs::MarkerArray A_star_vis;

ros::Publisher queryPointEdt;
ros::Publisher plan_dur_pub;

ros::Publisher wayPointEdt;
int edt_count = 0;
octomap::point3d qPt;
bool queryPtUpdated = false;
bool controller_started = false;

// DynamicEDTOctomap *costMap;

/**********************************************************************************************************************************************************
 * -------------------------------------------------------------------Callbacks---------------------------------------------------------------------------*
 ***********************************************************************************************************************************************************/

/** octomap callback **/
void octomap_cb(const octomap_msgs::Octomap octo)
{
    costMap3D.new_tree = octomap_msgs::binaryMsgToMap(octo); // this is the abstract tree for an octomap
    // MMD_Costmap.new_mmd_tree = octomap_msgs::binaryMsgToMap(octo);

    costMap3D.tree = dynamic_cast<octomap::OcTree *>(costMap3D.new_tree);
    // MMD_Costmap.mmd_tree = dynamic_cast<octomap::OcTree*>(MMD_Costmap.mmd_tree);

    // std::cout<<"final tree has "<<costMap3D.tree->getNumLeafNodes()<<" leaves"<<std::endl;

    // get the min and max of the map
    costMap3D.setMinMax();
    // MMD_Costmap.setMinMax_mmd();
    costMap3D.isOctomapUpdated = true;
    // MMD_Costmap.isOctomapUpdated_mmd = true;
}

/** current drone position callback **/
void local_pose_cb(const geometry_msgs::PoseStamped pose)
{
    currPose(0) = pose.pose.position.x;
    currPose(1) = pose.pose.position.y;
    currPose(2) = pose.pose.position.z;
}

/** get goal location **/
void goal_pose_cb(const geometry_msgs::PoseStamped pose)
{
    goalReceived = true;
    double dummy = 0;

    goalPose(0) = pose.pose.position.x; //  17.6733, 5.064 , 4.0

    goalPose(1) = pose.pose.position.y;

    goalPose(2) = 4;

    // std::cout<<"Enter the height at the goal point ";
    // std::cin>>goalPose(2);

    std::cout << "Goal Pose is ...*********** " << goalPose.transpose() << std::endl;
    std::cout << "\n";

    // std::cout<<"Enter the height at the goal point ";
    // std::cin>>dummy;
}

/** query edt for any published point **/
void edt_cb(const geometry_msgs::PoseStamped msg)
{
    octomap::point3d queryPt(msg.pose.position.x, msg.pose.position.y, msg.pose.position.z);

    std::cout << "Here " << std::endl;
    qPt = queryPt;
    queryPtUpdated = true;
    DynamicEDTOctomap costMap(5.0, costMap3D.tree, costMap3D.start, costMap3D.end, false);
    costMap.update();

    // check if the point is in the map
    std_msgs::Float64 edt;
    if (costMap3D.isInMap(queryPt))
    {
        // std::cout<<costMap3D.start<<"  "<<costMap3D.end<<std::endl;
        std::cout << "Inside Map" << std::endl;
        std::cout << queryPt << std::endl;
        float dist = costMap.getDistance(queryPt);
        // float dist;
        octomap::point3d closest_obs;
        // costMap.getDistanceAndClosestObstacle(queryPt, dist , closest_obs);
        std::cout << "Distance of queried point " << queryPt << " is :-> " << dist << std::endl;

        std::cout << closest_obs << std::endl;

        edt.data = dist;
    }

    else
    {
        edt.data = 1000;
    }
    queryPointEdt.publish(edt);
}

///////////////////////////////////////////////////////////////////
/**  Plan the path until goal is reached **/
void plan(ros::Publisher path, ros::Publisher map, ros::Publisher pathEDT, ros::Publisher MMD_map, ros::Publisher pathOriginal, ros::Publisher sample_trajectory_pub,
          visualization_msgs::MarkerArray A_star_vis, ros::Publisher A_star_pub, ros::Publisher plan_dur_pub)
{
    std::ofstream planning_time;
    planning_time.open("planning_time.dat");

    // auto plan_start =  std::chrono::high_resolution_clock::now();
    // auto plan_start = high_resolution_clock::now();
    // auto plan_start = ros::Time::now() ;
    while (!DESTINATION_REACHED || ros::ok()) /** until the goal is reached or the node is killed, keep running the process **/
    {
        if (!ros::ok())
        {
            break;
        }
        if (count == 0) // 1st iteration
        {
            std::cout << "Starting pose is " << currPose << std::endl;
            costMap3D.setStartPosition(currPose); // set this point as the point where map was initialized
            startPose = currPose;
            startPose(0) += 0.5; // start planning from a small distance away from the starting location
            PLAN = true;
            // count++;
        }
        else
        {
            if (costMap3D.ifUpdateMap(currPose))
            {
                costMap3D.setStartPosition(currPose);
                PLAN = true;
                // count++;
            }
            else
            {
                if (!ros::ok)
                {
                    break;
                }
                PLAN = false;
                ros::spinOnce();
                continue;
            }
        }

        if (PLAN)
        {
            PLAN = false;

            // set the map range with respect to the current point
            costMap3D.setMapRange(currPose);

            std::cout << "Updating the map from ... " << costMap3D.start << " to" << costMap3D.end << std::endl;

            // calculate EDT now
            // DynamicEDTOctomap DistMap(5.0, costMap3D.tree, costMap3D.start, costMap3D.end, false); // take unknwon region as unoccupied
            // function desription =  DynamicEDTOctomapBase<TREE>::DynamicEDTOctomapBase(float maxdist, TREE* _octree, octomap::point3d bbxMin, octomap::point3d bbxMax, bool treatUnknownAsOccupied)

            DynamicEDTOctomap DistMap(5.0, costMap3D.tree, costMap3D.start, costMap3D.end, false); // take unknwon region as unoccupied
            DistMap.update();

            octomap::point3d qp(24.23, 0.0, 1.25);

            // set this as the costMap in the costMap3D object
            costMap3D.costMap = &DistMap;
            // MMD_costmap.EDT_Map = &DistMap;

            if (queryPtUpdated)
            {
                std::cout << "--------------------------------------------------------------- Distance is " << costMap3D.costMap->getDistance(qp) << std::endl;
                std_msgs::Float64 edt;
                edt.data = costMap3D.costMap->getDistance(qPt);
                queryPointEdt.publish(edt);
                queryPtUpdated = false;
            }

            // set planning range and pass cost map to planner
            kAstar.init(costMap3D.start, costMap3D.end, currPose);
            kAstar.setEnvironment(&DistMap, costMap3D.tree, costMap3D.new_tree, costMap3D.start, costMap3D.end);

            // visualize the EDT Map

            costMap3D.getCostMapMarker(costMap_vis, &DistMap, map);

            // auto start =  std::chrono::high_resolution_clock::now();
            // auto start = high_resolution_clock::now();
            auto start = ros::Time::now();

            // costMap3D.get_MMD_Map_Marker(MMD_map_vis, &DistMap, MMD_map);

            // MMD_costmap.visulize_MMD_Map_Marker(MMD_map_vis, &DistMap, MMD_map );
            // auto stop =   high_resolution_clock::now();
            auto stop = ros::Time::now();
            // auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
            // auto duration = duration_cast<microseconds>(stop-start);

            // std::cout << " --------------------------- " << " entered the visulizer  " << duration.count()     << std::endl;

            // plan_start =  auto start = high_resolution_clock::now();
            // auto plan_start = high_resolution_clock::now();
            auto plan_start = ros::Time::now();
            // run the planner now
            int status;
            float time_to_desination; // to be sent for CE optimization
            bool temp_status;

            if (count == 0 || startOver == 1)
            {
                status = kAstar.search(startPose, startVel, startAcc, goalPose, goalVel, time_to_desination, true, MMD_map_vis, MMD_map, A_star_vis, A_star_pub, path_to_weights, false, 0.0);
                startOver = 0;
                ros::spinOnce();
            }
            else
            {
                status = kAstar.search(startPose, startVel, startAcc, goalPose, goalVel, time_to_desination, false, MMD_map_vis, MMD_map, A_star_vis, A_star_pub, path_to_weights, false, 0.0);
                ros::spinOnce();
            }

            std::cout << "Planner output status is >>>>> " << status << std::endl;
            std::cout << "\n";

            if (status == 3)
            {
                std::cout << "No trajectory found ..." << std::endl;
                std::cout << "Trying again ..." << std::endl;
                std::cout << "\n";
                ros::spinOnce();
                return;
            }

            if (status == 2)
            {
                std::cout << "+++++++++++__________________Goal reached__________________++++++++++++ ...." << std::endl;
                DESTINATION_REACHED = false; // this was initlially true changed to fasle to keep the code in the loop for the MMD calculaiton to take place
                // break;
            }

            /** get the planned path **/

            Bernstein::BernsteinPath BernsteinTraj(10);

            std::vector<Eigen::Vector3d> currTraj = kAstar.getKinoTraj(deltaT);
            prevTraj = currTraj;

            for (auto i = currTraj.begin(); i != currTraj.end(); i++)
            {
                geometry_msgs::PoseStamped p;
                Eigen::Vector3d pos = *i;

                p.pose.position.x = pos(0);
                p.pose.position.y = pos(1);
                p.pose.position.z = pos(2);

                p.pose.orientation.w = 1.0;

                fastPlannerOriginal.poses.push_back(p);
                fastPlannerOriginal.header.stamp = ros::Time::now();
                fastPlannerOriginal.header.frame_id = "/map";
            }

            pathOriginal.publish(fastPlannerOriginal);
            std::cout << "Published the original trajectory " << std::endl;

            count++;

            float execTime = 2;

            std::vector<Eigen::Vector3d> cTraj;

            for (int i = 0; i < currTraj.size(); i++)
            {
                cTraj.push_back(currTraj.at(i));
            }

            std::vector<Eigen::Vector3d> optimalTrajectory;

            if (cTraj.size() > 2)
            {
                optimalTrajectory = optimizer.optimizeTrajectory(BernsteinTraj, cTraj, execTime, costMap3D, sample_trajectory_pub, plan_dur_pub, path_to_weights);

                for (auto i = optimalTrajectory.begin(); i != optimalTrajectory.end(); i++)
                {
                    geometry_msgs::PoseStamped p;

                    geometry_msgs::PoseStamped pEdt;

                    Eigen::Vector3d pos = *i;
                    Eigen::Vector3d pos_next;

                    // store the distance to nearest obstacle for each wayoint
                    octomap::point3d pt_(pos(0), pos(1), pos(2));
                    octomap::point3d ptObs;

                    float dist;
                    DistMap.getDistanceAndClosestObstacle(pt_, dist, ptObs);
                    // pEdt.pose.position.x = ptObs.x();
                    // pEdt.pose.position.y = ptObs.y();
                    // pEdt.pose.position.z = ptObs.z();

                    // generatedPathEDT.header.stamp = ros::Time::now();
                    // generatedPathEDT.header.frame_id = "map";
                    // generatedPathEDT.poses.push_back(pEdt);

                    //  std::cout<<"Waypoint in current trajectory ..."<<pos<<std::endl;

                    if (-INF < pos(0) < INF && -INF < pos(1) < INF && -INF < pos(2) < INF)
                    {
                        p.pose.position.x = pos(0);
                        p.pose.position.y = pos(1);
                        p.pose.position.z = pos(2);
                        p.pose.orientation.x = dist;

                        if (i != optimalTrajectory.end() - 1)
                        {
                            pos_next = *(i + 1);

                            float currYaw = atan2((pos_next(1) - pos(1)), (pos_next(0) - pos(0)));
                            float qz = sin(currYaw / 2.0);
                            float qw = cos(currYaw / 2.0);

                            p.pose.orientation.y = 0.0;
                            p.pose.orientation.z = qz;
                            p.pose.orientation.w = qw;

                            generatedPath.header.stamp = ros::Time::now();
                            generatedPath.header.frame_id = "map";
                            generatedPath.poses.push_back(p);
                        }
                    }
                    ros::spinOnce();
                }

                // publish the path
                path.publish(generatedPath);
            }

            auto plan_end = ros::Time::now();
            // auto plan_end = high_resolution_clock::now();

            auto plan_duration = plan_end - plan_start;
            // publish the EDT data for the path
            // pathEDT.publish(generatedPathEDT);

            // insert this in the global trajectory

            trajectory.insert(trajectory.end(), optimalTrajectory.begin(), optimalTrajectory.end());
            // std::cout<<"Global trajectory size ... "<<trajectory.size()<<   "  " <<     std::endl;
            planning_time << plan_duration.toSec() << std::endl;

            std_msgs::Float64 plan_time;
            plan_time.data = plan_duration.toSec();
            // plan_dur_pub.publish(plan_time);

            // std::cout<<"\n";

            // trajectory.insert(trajectory.end(), optimalTrajectory.begin(), optimalTrajectory.end());
            // std::cout<<"Global trajectory size ... "<<trajectory.size()<<   "  " << "plan time +++++++++++++++ " << plan_duration.count()<<     std::endl;
            // planning_time <<  float(plan_duration.count()/1000000.0) << std::endl;
            // std::cout<<"\n";

            kAstar.reset();
            ros::spinOnce();

            if (!ros::ok() || status == 2)
            {
                if (status == 2)
                {
                    std::cout << "***************** Reached goal ********************" << std::endl;
                    planning_time.close();
                    return;
                }
                break;
            }

            // set the starting point for the next planning iteration
            auto it = trajectory.end() - 1;
            startPose = *it;
            std::cout << ">>>>>>>>>>>>>>__________Next starting point for the planner is " << startPose.transpose() << std::endl;
            std::cout << "\n";
        }
        ros::spinOnce();

        if (!ros::ok())
        {
            break;
        }
    }
}

void EDT_wpt(const geometry_msgs::PoseStamped curr_pose)
{

    curr_pose_EDT(0) = curr_pose.pose.position.x;
    curr_pose_EDT(1) = curr_pose.pose.position.y;
    curr_pose_EDT(2) = curr_pose.pose.position.z;

    octomap::point3d queryPt2(curr_pose_EDT(0), curr_pose_EDT(1), curr_pose_EDT(2));

    queryPtUpdated = true;
    DynamicEDTOctomap costMap_new(5.0, costMap3D.tree, costMap3D.start, costMap3D.end, true);
    if (controller_started)
    {
        costMap_new.update();

        // check if the point is in the map
        std_msgs::Float64 waypt_Edt_dist;
        if (costMap3D.isInMap(queryPt2))
        {
            // std::cout<<costMap3D.start<<"  "<<costMap3D.end<<std::endl;
            // std::cout<<"Inside publishing for trajectory"<<std::endl;
            // std::cout<<queryPt<<std::endl;
            float dist = costMap_new.getDistance(queryPt2);
            // std::cout<<"Distance of queried point "<<queryPt2<<" is :-> "<<dist<<std::endl;

            waypt_Edt_dist.data = dist;
        }

        else
        {
            waypt_Edt_dist.data = 1000;
        }

        wayPointEdt.publish(waypt_Edt_dist);
    }
}

void start_cb(const std_msgs::Float64 start_val)
{

    float value = start_val.data;

    if (value == 1)
    {

        controller_started = true;
    }
}

int main(int argc, char **argv)
{
    /** set all the subscribers and publishers **/
    ros::init(argc, argv, "CCO_VOXEL");
    ros::NodeHandle n;

    n.getParam("Planner/path_to_weights", path_to_weights);

    /** Subscribers **/
    ros::Subscriber oct = n.subscribe<octomap_msgs::Octomap>("/octomap_binary", 1, octomap_cb);
    ros::Subscriber pos = n.subscribe<geometry_msgs::PoseStamped>("/mavros/local_position/pose", 10, local_pose_cb);
    ros::Subscriber goal = n.subscribe<geometry_msgs::PoseStamped>("/move_base_simple/goal", 1, goal_pose_cb);
    // ros::Subscriber EDT_to_waypoint = n.subscribe<geometry_msgs::PoseStamped>("/mavros/local_position/pose",10,EDT_wpt);

    /** Publishers **/
    ros::Publisher path = n.advertise<nav_msgs::Path>("/fastPlanner_path", 1);
    ros::Publisher map = n.advertise<visualization_msgs::MarkerArray>("/costMap_marker_array", 1); // one at a time
    ros::Publisher pathEDT = n.advertise<nav_msgs::Path>("/fastPlanner_path_EDT", 1);
    ros::Publisher MMD_map = n.advertise<visualization_msgs::MarkerArray>("/MMD_marker_array", 1);
    ros::Publisher pathOriginal = n.advertise<nav_msgs::Path>("/fastPlanner_original", 1);
    ros::Publisher sample_trajectory_pub = n.advertise<visualization_msgs::Marker>("/sample_trajectories", 0);
    ros::Publisher A_star_pub = n.advertise<visualization_msgs::MarkerArray>("/A_star", 1);

    ros::Publisher plan_dur_pub = n.advertise<std_msgs::Float64>("/distance_data", 10);

    /** EDT Subscriber and distance publisher **/
    ros::Subscriber queryPoint = n.subscribe<geometry_msgs::PoseStamped>("/QueryPoint", 1, edt_cb);
    queryPointEdt = n.advertise<std_msgs::Float64>("/EDT_QueryPoint", 1);

    wayPointEdt = n.advertise<std_msgs::Float64>("/way_pt_EDT", 1);
    ros::Subscriber controller_start = n.subscribe<std_msgs::Float64>("/Start_cmd", 1, start_cb);

    ros::Rate rate(20);

    std::cout << "Started the Planner give a point to initiate planning to a pre defined goal  ";
    // std::cin>>startOver;

    while (!goalReceived)
    {
        // std::cout<<"Waiting for goal ..."<<std::endl;
        ros::spinOnce();
        rate.sleep();

        if (!ros::ok())
        {
            break;
        }
    }

    if (goalReceived)
    {
        std::cout << "Goal received " << goalPose.transpose() << std::endl;
        std::cout << "\n";
        std::cout << "Setting initial velocity and acceleration .." << std::endl;

        goalVel = Eigen::Vector3d::Zero();  // velocity at goal location set to 0
        startVel = Eigen::Vector3d::Zero(); // starting with 0 initial velocity i.e. static
        startAcc = Eigen::Vector3d::Ones(); // set the starting acceleration as (1,1,1)

        std::cout << "Starting planning now ..." << std::endl;

        kAstar.setParam(n); // set the fast planner parameters

        plan(path, map, pathEDT, MMD_map, pathOriginal, sample_trajectory_pub, A_star_vis, A_star_pub, plan_dur_pub);
    }

    return 0;
}